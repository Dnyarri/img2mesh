#!/usr/bin/env python3

"""
IMG2OBJ - Conversion of image heightfield to triangle mesh in Wavefront OBJ format
-----------------------------------------------------------------------------------

Created by: Ilya Razmanov (mailto:ilyarazmanov@gmail.com) aka Ilyich the Toad (mailto:amphisoft@gmail.com)

Overview:
----------

list2obj present function for converting image-like nested X,Y,Z int lists to 3D triangle mesh height field in Wavefront OBJ format.

Usage:
-------

`list2obj.list2obj(image3d, maxcolors, result_file_name)`

where:

`image3d` - image as list of lists of lists of int channel values.

`maxcolors` - maximum value of int in `image3d` list.

`result_file_name` - name of OBJ file to export.

History:
---------

1.0.0.0     Initial production release.

1.9.1.0     Multiple changes lead to whole product update. Versioning changed to MAINVERSION.MONTH_since_Jan_2024.DAY.subversion

1.13.4.0    Rewritten from standalone img2obj to module list2obj.

-------------------
Main site:
https://dnyarri.github.io

Project mirrored at:
https://github.com/Dnyarri/img2mesh; https://gitflic.ru/project/dnyarri/img2mesh

"""

__author__ = 'Ilya Razmanov'
__copyright__ = '(c) 2024-2025 Ilya Razmanov'
__credits__ = 'Ilya Razmanov'
__license__ = 'unlicense'
__version__ = '1.14.1.1'
__maintainer__ = 'Ilya Razmanov'
__email__ = 'ilyarazmanov@gmail.com'
__status__ = 'Production'


def list2obj(image3d: list[list[list[int]]], maxcolors: int, resultfilename: str) -> None:
    """Converting nested 3D list to Wavefront OBJ heightfield triangle mesh.

    `image3d` - image as list of lists of lists of int channel values.

    `maxcolors` - maximum value of int in `image3d` list.

    `resultfilename` - name of OBJ file to export.

    """

    # Determining list sizes
    Y = len(image3d)
    X = len(image3d[0])
    Z = len(image3d[0][0])

    """ ╔═══════════════╗
        ║ src functions ║
        ╚═══════════════╝ """

    def src(x: int | float, y: int | float, z: int) -> int | float:
        """
        Analog of src from FilterMeister, force repeat edge instead of out of range.
        Returns int channel z value for pixel x, y

        """

        cx = int(x)
        cy = int(y)  # nearest neighbor for float input
        cx = max(0, cx)
        cx = min((X - 1), cx)
        cy = max(0, cy)
        cy = min((Y - 1), cy)

        channelvalue = image3d[cy][cx][z]

        return channelvalue

    # end of src function

    def src_lum(x: int | float, y: int | float) -> int | float:
        """
        Returns brightness of pixel x, y

        """

        if Z < 3:  # supposedly L and LA
            yntensity = src(x, y, 0)
        else:  # supposedly RGB and RGBA
            yntensity = int(0.2989 * src(x, y, 0) + 0.587 * src(x, y, 1) + 0.114 * src(x, y, 2))

        return yntensity

    # end of src_lum function

    """ ╔══════════════════╗
        ║ Writing OBJ file ║
        ╚══════════════════╝ """

    # Global positioning and scaling to tweak.

    xOffset = -0.5 * float(X - 1)  # To be added BEFORE rescaling to center object.
    yOffset = -0.5 * float(Y - 1)  # To be added BEFORE rescaling to center object
    zOffset = 0.0

    yRescale = xRescale = 1.0 / float(max(X, Y))  # To fit object into 1,1,1 cube
    zRescale = 1.0 / float(maxcolors)

    resultfile = open(resultfilename, 'w')

    """ ┌────────────┐
        │ OBJ header │
        └────────────┘ """

    resultfile.write(f'# Generated by: {__file__} version: {__version__}\n')  # opening object
    resultfile.write('o pryanik_nepechatnyj\n')  # opening object

    """ ┌──────┐
        │ Mesh │
        └──────┘ """

    for y in range(0, Y, 1):
        for x in range(0, X, 1):
            # Reading switch:
            xRead = x
            yRead = Y - 1 - y

            # Remains of Writing switch. No longer used since v. 0.1.0.2 but var names remained so dummy plug must be here.
            xWrite = x
            yWrite = y

            """Pyramid structure around default pixel 9.
            Remember yRead = Y - 1 - y
            ┌───┬───┬───┐
            │ 1 │   │ 3 │
            ├───┼───┼───┤
            │   │ 9 │   │
            ├───┼───┼───┤
            │ 7 │   │ 5 │
            └───┴───┴───┘
            """
            v9 = src_lum(xRead, yRead)  # Current pixel to process and write. Then going to neighbours
            v1 = 0.25 * (v9 + src_lum((xRead - 1), yRead) + src_lum((xRead - 1), (yRead + 1)) + src_lum(xRead, (yRead + 1)))
            v3 = 0.25 * (v9 + src_lum(xRead, (yRead + 1)) + src_lum((xRead + 1), (yRead + 1)) + src_lum((xRead + 1), yRead))
            v5 = 0.25 * (v9 + src_lum((xRead + 1), yRead) + src_lum((xRead + 1), (yRead - 1)) + src_lum(xRead, (yRead - 1)))
            v7 = 0.25 * (v9 + src_lum(xRead, (yRead - 1)) + src_lum((xRead - 1), (yRead - 1)) + src_lum((xRead - 1), yRead))

            # finally going to pyramid building

            # top part begins
            resultfile.writelines(
                [
                    f'v {(xRescale * (xWrite - 0.5 + xOffset)):e} {(yRescale * (yWrite - 0.5 + yOffset)):e} {(zOffset + zRescale * v1):e}\n',
                    f'v {(xRescale * (xWrite + xOffset)):e} {(yRescale * (yWrite + yOffset)):e} {(zOffset + zRescale * v9):e}\n',
                    f'v {(xRescale * (xWrite + 0.5 + xOffset)):e} {(yRescale * (yWrite - 0.5 + yOffset)):e} {(zOffset + zRescale * v3):e}\n',
                    'f -3 -2 -1\n',  # triangle 2
                    f'v {(xRescale * (xWrite + 0.5 + xOffset)):e} {(yRescale * (yWrite - 0.5 + yOffset)):e} {(zOffset + zRescale * v3):e}\n',
                    f'v {(xRescale * (xWrite + xOffset)):e} {(yRescale * (yWrite + yOffset)):e} {(zOffset + zRescale * v9):e}\n',
                    f'v {(xRescale * (xWrite + 0.5 + xOffset)):e} {(yRescale * (yWrite + 0.5 + yOffset)):e} {(zOffset + zRescale * v5):e}\n',
                    'f -3 -2 -1\n',  # triangle 4
                    f'v {(xRescale * (xWrite + 0.5 + xOffset)):e} {(yRescale * (yWrite + 0.5 + yOffset)):e} {(zOffset + zRescale * v5):e}\n',
                    f'v {(xRescale * (xWrite + xOffset)):e} {(yRescale * (yWrite + yOffset)):e} {(zOffset + zRescale * v9):e}\n',
                    f'v {(xRescale * (xWrite - 0.5 + xOffset)):e} {(yRescale * (yWrite + 0.5 + yOffset)):e} {(zOffset + zRescale * v7):e}\n',
                    'f -3 -2 -1\n',  # triangle 6
                    f'v {(xRescale * (xWrite - 0.5 + xOffset)):e} {(yRescale * (yWrite + 0.5 + yOffset)):e} {(zOffset + zRescale * v7):e}\n',
                    f'v {(xRescale * (xWrite + xOffset)):e} {(yRescale * (yWrite + yOffset)):e} {(zOffset + zRescale * v9):e}\n',
                    f'v {(xRescale * (xWrite - 0.5 + xOffset)):e} {(yRescale * (yWrite - 0.5 + yOffset)):e} {(zOffset + zRescale * v1):e}\n',
                    'f -3 -2 -1\n',  # triangle 8
                ]
            )
            # top part ends

    resultfile.write('# end pryanik_nepechatnyj')  # closing object

    # Close output
    resultfile.close()

    return None


# Procedure end, main body begins
if __name__ == '__main__':
    print('Module to be imported, not run as standalone')
