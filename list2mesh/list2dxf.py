#!/usr/bin/env python3

"""
IMG2DXF - Conversion of image heightfield to triangle mesh in Autodesk DXF format
-----------------------------------------------------------------------------------

Created by: Ilya Razmanov (mailto:ilyarazmanov@gmail.com) aka Ilyich the Toad (mailto:amphisoft@gmail.com)

Overview:
----------

list2dxf present function for converting image-like nested X,Y,Z int lists to 3D triangle mesh height field in Autodesk DXF format.

Usage:
-------

`list2dxf.list2dxf(image3d, maxcolors, result_file_name)`

where:

`image3d` - image as list of lists of lists of int channel values.

`maxcolors` - maximum value of int in `image3d` list.

`result_file_name` - name of DXF file to export.

History:
---------

0.0.0.1     Development started 23 Aug 2024.

1.9.1.0     First production release. Versioning set to MAINVERSION.MONTH_since_Jan_2024.DAY.subversion

1.13.4.0    Rewritten from standalone img2dxf to module list2dxf.

-------------------
Main site:
https://dnyarri.github.io

Project mirrored at:
https://github.com/Dnyarri/img2mesh; https://gitflic.ru/project/dnyarri/img2mesh

"""

__author__ = 'Ilya Razmanov'
__copyright__ = '(c) 2024-2025 Ilya Razmanov'
__credits__ = 'Ilya Razmanov'
__license__ = 'unlicense'
__version__ = '1.14.1.1'
__maintainer__ = 'Ilya Razmanov'
__email__ = 'ilyarazmanov@gmail.com'
__status__ = 'Production'


def list2dxf(image3d: list[list[list[int]]], maxcolors: int, resultfilename: str) -> None:
    """Converting nested 3D list to Autodesk DXF heightfield triangle mesh.

    `image3d` - image as list of lists of lists of int channel values.

    `maxcolors` - maximum value of int in `image3d` list.

    `resultfilename` - name of DXF file to export.

    """

    # Determining list sizes
    Y = len(image3d)
    X = len(image3d[0])
    Z = len(image3d[0][0])

    """ ╔═══════════════╗
        ║ src functions ║
        ╚═══════════════╝ """

    def src(x: int | float, y: int | float, z: int) -> int | float:
        """
        Analog of src from FilterMeister, force repeat edge instead of out of range.
        Returns int channel z value for pixel x, y

        """

        cx = int(x)
        cy = int(y)  # nearest neighbor for float input
        cx = max(0, cx)
        cx = min((X - 1), cx)
        cy = max(0, cy)
        cy = min((Y - 1), cy)

        channelvalue = image3d[cy][cx][z]

        return channelvalue

    # end of src function

    def src_lum(x: int | float, y: int | float) -> int | float:
        """
        Returns brightness of pixel x, y

        """

        if Z < 3:  # supposedly L and LA
            yntensity = src(x, y, 0)
        else:  # supposedly RGB and RGBA
            yntensity = int(0.2989 * src(x, y, 0) + 0.587 * src(x, y, 1) + 0.114 * src(x, y, 2))

        return yntensity

    # end of src_lum function

    """ ╔══════════════════╗
        ║ Writing DXF file ║
        ╚══════════════════╝ """

    # Global positioning and scaling to tweak.

    xOffset = -0.5 * float(X - 1)  # To be added BEFORE rescaling to center object.
    yOffset = -0.5 * float(Y - 1)  # To be added BEFORE rescaling to center object
    zOffset = 0.0

    yRescale = xRescale = 1.0 / float(max(X, Y))  # To fit object into 1,1,1 cube
    zRescale = 1.0 / float(maxcolors)

    # WRITING DXF FILE, finally
    # Based on specs at: https://images.autodesk.com/adsk/files/autocad_2012_pdf_dxf-reference_enu.pdf

    resultfile = open(resultfilename, 'w')

    """ ┌────────────┐
        │ DXF header │
        └────────────┘ """

    resultfile.writelines(
        [
            f'999\nGenerated by: {__file__} ver.: {__version__}\n0\nSECTION\n2\nHEADER\n0\nENDSEC\n0\n',
            'SECTION\n2\nTABLES\n0\nTABLE\n2\nLAYER\n70\n5\n0\nLAYER\n2\nPRYANIK\n70\n0\n62\n1\n6\nCONTINUOUS\n0\nENDTAB\n0\nENDSEC\n0\n',
            'SECTION\n2\nENTITIES\n0\n',
        ]
    )

    """ ┌──────┐
        │ Mesh │
        └──────┘ """

    # Now going to cycle through image and build mesh

    for y in range(0, Y, 1):
        for x in range(0, X, 1):
            # Since I was unable to find clear declaration of coordinate system, I'll plug a coordinate switch here

            # Reading switch:
            xRead = x
            yRead = Y - 1 - y
            # 'yRead = Y - y' coordinate mirror to mimic Photoshop coordinate system; +/- 1 steps below are inverted correspondingly vs. original img2mesh

            # Remains of Writing switch. No longer used but var names remained so dummy plug must be here.
            xWrite = x
            yWrite = y

            """Pyramid structure around default pixel 9.
            Remember yRead = Y - 1 - y
            ┌───┬───┬───┐
            │ 1 │   │ 3 │
            ├───┼───┼───┤
            │   │ 9 │   │
            ├───┼───┼───┤
            │ 7 │   │ 5 │
            └───┴───┴───┘
            """
            v9 = src_lum(xRead, yRead)  # Current pixel to process and write. Then going to neighbours
            v1 = 0.25 * (v9 + src_lum((xRead - 1), yRead) + src_lum((xRead - 1), (yRead + 1)) + src_lum(xRead, (yRead + 1)))
            v3 = 0.25 * (v9 + src_lum(xRead, (yRead + 1)) + src_lum((xRead + 1), (yRead + 1)) + src_lum((xRead + 1), yRead))
            v5 = 0.25 * (v9 + src_lum((xRead + 1), yRead) + src_lum((xRead + 1), (yRead - 1)) + src_lum(xRead, (yRead - 1)))
            v7 = 0.25 * (v9 + src_lum(xRead, (yRead - 1)) + src_lum((xRead - 1), (yRead - 1)) + src_lum((xRead - 1), yRead))

            # finally going to pyramid building

            # top part begins
            resultfile.writelines(
                [
                    '3DFACE\n8\nPRYANIK\n',  # Opening triangle 2
                    f'10\n{(xRescale * (xWrite - 0.5 + xOffset)):f}\n20\n{(yRescale * (yWrite - 0.5 + yOffset)):f}\n30\n{(zOffset + zRescale * v1):f}\n',
                    f'11\n{(xRescale * (xWrite + xOffset)):f}\n21\n{(yRescale * (yWrite + yOffset)):f}\n31\n{(zOffset + zRescale * v9):f}\n',
                    f'12\n{(xRescale * (xWrite + 0.5 + xOffset)):f}\n22\n{(yRescale * (yWrite - 0.5 + yOffset)):f}\n32\n{(zOffset + zRescale * v3):f}\n',
                    '62\n0\n0\n',  # triangle 2
                    '3DFACE\n8\nPRYANIK\n',  # Opening triangle 4
                    f'10\n{(xRescale * (xWrite + 0.5 + xOffset)):f}\n20\n{(yRescale * (yWrite - 0.5 + yOffset)):f}\n30\n{(zOffset + zRescale * v3):f}\n',
                    f'11\n{(xRescale * (xWrite + xOffset)):f}\n21\n{(yRescale * (yWrite + yOffset)):f}\n31\n{(zOffset + zRescale * v9):f}\n',
                    f'12\n{(xRescale * (xWrite + 0.5 + xOffset)):f}\n22\n{(yRescale * (yWrite + 0.5 + yOffset)):f}\n32\n{(zOffset + zRescale * v5):f}\n',
                    '62\n0\n0\n',  # triangle 4
                    '3DFACE\n8\nPRYANIK\n',  # Opening triangle 6
                    f'10\n{(xRescale * (xWrite + 0.5 + xOffset)):f}\n20\n{(yRescale * (yWrite + 0.5 + yOffset)):f}\n30\n{(zOffset + zRescale * v5):f}\n',
                    f'11\n{(xRescale * (xWrite + xOffset)):f}\n21\n{(yRescale * (yWrite + yOffset)):f}\n31\n{(zOffset + zRescale * v9):f}\n',
                    f'12\n{(xRescale * (xWrite - 0.5 + xOffset)):f}\n22\n{(yRescale * (yWrite + 0.5 + yOffset)):f}\n32\n{(zOffset + zRescale * v7):f}\n',
                    '62\n0\n0\n',  # triangle 6
                    '3DFACE\n8\nPRYANIK\n',  # Opening triangle 8
                    f'10\n{(xRescale * (xWrite - 0.5 + xOffset)):f}\n20\n{(yRescale * (yWrite + 0.5 + yOffset)):f}\n30\n{(zOffset + zRescale * v7):f}\n',
                    f'11\n{(xRescale * (xWrite + xOffset)):f}\n21\n{(yRescale * (yWrite + yOffset)):f}\n31\n{(zOffset + zRescale * v9):f}\n',
                    f'12\n{(xRescale * (xWrite - 0.5 + xOffset)):f}\n22\n{(yRescale * (yWrite - 0.5 + yOffset)):f}\n32\n{(zOffset + zRescale * v1):f}\n',
                    '62\n0\n0\n',  # triangle 8
                ]
            )
            # top part ends

    resultfile.write('ENDSEC\n0\nEOF\n')  # closing object

    # Close output
    resultfile.close()

    return None


# Procedure end, main body begins
if __name__ == '__main__':
    print('Module to be imported, not run as standalone')
